# -*- coding: utf-8 -*-
"""Archetype 1 - shared resource parallel ops.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1X2379huLUU0AcjmUmAJb01xuBajXBkOE
"""

pip install simpy

import simpy
import numpy as np
import pandas as pd
import bokeh

#containers
    #raw materials, A and B components, C assembly
rawMatCapa = 4000
aInvCapa = 1000
bInvCapa = 1000
cInvCapa = 1000

class Factory:
    def __init__(self, env):
        self.rawMat = simpy.Container(env, capacity = rawMatCapa, init = 4000)
        self.aInv = simpy.Container(env ,capacity = aInvCapa, init = 20)
        self.bInv = simpy.Container(env ,capacity = bInvCapa, init = 20)
        self.cInv = simpy.Container(env ,capacity = cInvCapa, init = 10)

dfA = pd.DataFrame(columns=['id','activity','start','end','A produced'])
dfB = pd.DataFrame(columns=['id','activity','start','end','B produced'])
dfC = pd.DataFrame(columns=['id','activity','start','end','C produced'])

def print_stats_res(res, process):
  print(f'{res.count} of {res.capacity} are alocated to {process}')

def a_maker(env, res, factory, batchsizeA, dfA, var):
    while True:
      with res.request() as req:
        yield req
        randomizedBatchA = np.random.randint(1, var)*batchsizeA
        yield factory.rawMat.get(randomizedBatchA)
        a_cycletime = 1
        start = env.now
        yield env.timeout(a_cycletime*randomizedBatchA)
        yield factory.aInv.put(randomizedBatchA)
        end = env.now
        #print_stats_res(res, 'process A')
        dfA.loc[len(dfA)]=['A','manufacturing',start,end,randomizedBatchA]


def b_maker(env, res, factory, batchsizeB, dfB, var):
    while True:
      with res.request() as req:
        yield req
        randomizedBatchB = np.random.randint(1, var)*batchsizeB
        yield factory.rawMat.get(randomizedBatchB)
        start = env.now
        b_cycletime = 1
        yield env.timeout(b_cycletime*randomizedBatchB)
        yield factory.bInv.put(randomizedBatchB)
        end = env.now
        #print_stats_res(res, 'process B')
        dfB.loc[len(dfB)]=['B','manufacturing',start,end,randomizedBatchB]

def c_maker(env, factory, dfC):
    while True:
        yield factory.aInv.get(1)
        yield factory.bInv.get(1)
        start = env.now
        c_cycletime = 1
        yield env.timeout(c_cycletime)
        yield factory.cInv.put(1)
        end = env.now
        dfC.loc[len(dfC)]=['C','assembly',start,end,1]

import statistics as st
outputs = list()
invs = list()

for _ in range(1,40):
  total_time = 1000
  batchsizeA = 50
  batchsizeB = 50
  var = 3
  env = simpy.Environment()
  factory = Factory(env)
  res = simpy.Resource(env, capacity = 1)
  dfA = pd.DataFrame(columns=dfA.columns)
  dfB = pd.DataFrame(columns=dfB.columns)
  dfC = pd.DataFrame(columns=dfC.columns)
  a_process = env.process(a_maker(env, res, factory, batchsizeA, dfA, var))
  b_process = env.process(b_maker(env, res, factory, batchsizeB, dfB, var))
  c_process = env.process(c_maker(env, factory, dfC))

  env.run(until = total_time)
  outputs.append(factory.cInv.level)
  invs.append(factory.aInv.level+factory.bInv.level)

print(outputs)
print(st.mean(outputs))
print(st.mean(invs))

df = pd.concat([dfA,dfB,dfC], ignore_index=True)
df = df.sort_values(by='end')
df = df.fillna(0)
display(df)

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline
import matplotlib.pyplot as plt
from matplotlib.lines import Line2D

def gantt(df, lw=10):

    # create sorted lists of the unique ids and activities appearing in the data log
    ids = sorted(list(set(df["id"])))
    activities = sorted(list(set(df["activity"])))

    # create list of unique colors for each event
    colors = [f"C{i}" for i in range(len(activities))]

    # create plot window
    fig, ax = plt.subplots(1, 1, figsize=(10, 3))

    # for each event and id, find entries in the data log and plot the begin and end points
    for i, activity in enumerate(activities):
        for j, id in enumerate(ids):
            for k in df[(df["id"]==id) & (df["activity"]==activity)].index:
                ax.plot([df["start"][k], df["end"][k]], [j, j], colors[i], solid_capstyle="butt", lw=lw)

    # create legend
    lines = [Line2D([0], [0], lw=lw, color=colors[i]) for i in range(len(activities))]
    ax.legend(lines, activities, bbox_to_anchor=(1.05, 1.0), loc="upper left")

    # annotate the axes
    ax.set_yticks(range(len(ids)))
    ax.set_yticklabels(ids)
    ax.grid(True)
    ax.set_xlabel("Time")
    ax.set_title("Gantt Chart" )
    for sp in ['top', 'bottom', 'right', 'left']:
        ax.spines[sp].set_visible(False)

from bokeh.plotting import figure, output_notebook, show

def plot_production(df):
    output_notebook()
    # Create a Bokeh figure
    p = figure(width=800, height=400, title="Production Over Time", x_axis_label="End Time", y_axis_label="Production")

    # Plot production of each product
    if "A produced" in df.columns:
        p.line(df["end"], df['A produced'].cumsum(), legend_label="Product A", line_color="blue", line_width=2)
    if "B produced" in df.columns:
        p.line(df["end"], df["B produced"].cumsum(), legend_label="Product B", line_color="green", line_width=2)
    if "C produced" in df.columns:
        p.line(df["end"], df["C produced"].cumsum(), legend_label="Product C", line_color="red", line_width=2)

    # Add legend
    p.legend.location = "top_left"
    p.legend.click_policy = "hide"  # Clicking on legend entries hides the corresponding line

    # Show the plot
    show(p)

plot_production(df)

gantt(df)
